diff --git a/addons/calendar/models/calendar.py b/addons/calendar/models/calendar.py
index 793fd1055f7..29b64bf3748 100644
--- a/addons/calendar/models/calendar.py
+++ b/addons/calendar/models/calendar.py
@@ -1586,7 +1586,8 @@ class Meeting(models.Model):
 
         # offset, limit, order and count must be treated separately as we may need to deal with virtual ids
         events = super(Meeting, self).search(new_args, offset=0, limit=0, order=None, count=False)
-        events = self.browse(events.get_recurrent_ids(args, order=order))
+        if any(arg[0] in ('start', 'stop', 'final_date','start_date','stop_date') for arg in args):
+            events = self.browse(events.get_recurrent_ids(args, order=order))
         if count:
             return len(events)
         elif limit:
diff --git a/addons/sale/models/sale.py b/addons/sale/models/sale.py
index 947aa121a89..e4de1c13fdd 100644
--- a/addons/sale/models/sale.py
+++ b/addons/sale/models/sale.py
@@ -895,8 +895,8 @@ class SaleOrderLine(models.Model):
                 return result
 
         name = product.name_get()[0][1]
-        if product.description_sale:
-            name += '\n' + product.description_sale
+        #if product.description_sale:
+        #    name += '\n' + product.description_sale
         vals['name'] = name
 
         self._compute_tax_id()
diff --git a/addons/web/static/src/xml/base.xml b/addons/web/static/src/xml/base.xml
index 161509b364f..0ceb5f2fdb3 100644
--- a/addons/web/static/src/xml/base.xml
+++ b/addons/web/static/src/xml/base.xml
@@ -297,7 +297,7 @@
     </td>
 </tr>
 
-<div t-name="ListView" class="table-responsive">
+<div t-name="ListView">
     <table class="o_list_view table table-condensed table-striped">
         <t t-set="columns_count" t-value="visible_columns.length + (options.selectable ? 1 : 0) + (options.deletable ? 1 : 0)"/>
         <thead>
diff --git a/odoo/fields.py b/odoo/fields.py
index 81697970311..357c7f8b2e7 100644
--- a/odoo/fields.py
+++ b/odoo/fields.py
@@ -2067,6 +2067,8 @@ class _RelationalMulti(_Relational):
                 values = record._convert_to_write(values)
                 result.append((0, 0, values))
             elif record._is_dirty():
+                # take care of adding all existing even the edited ones
+                result[0][2].append(record.id)
                 values = {name: record[name] for name in record._get_dirty()}
                 values = record._convert_to_write(values)
                 result.append((1, record.id, values))
@@ -2080,15 +2082,17 @@ class _RelationalMulti(_Relational):
         # which fields are actually dirty
         converters = [(name, value._fields[name].convert_to_onchange)
                       for name in fnames if name != 'id']
-        result = [(5,)]
+        result = [(6, 0, [])]
         for record in value:
             vals = {name: convert(record[name], record) for name, convert in converters}
             if not record.id:
                 result.append((0, 0, vals))
             elif vals:
+                # take care of adding all existing even the edited ones
+                result[0][2].append(record.id)
                 result.append((1, record.id, vals))
             else:
-                result.append((4, record.id))
+                result[0][2].append(record.id)
         return result
 
     def convert_to_export(self, value, record):
@@ -2412,10 +2416,14 @@ class Many2many(_RelationalMulti):
                     """.format(**parts)
             cr.execute(query, (tuple(records.ids), tuple(ids)))
 
-        def unlink_all():
+        def unlink_all(keep_ids=None):
             # remove all records for which user has access rights
             clauses, params, tables = comodel.env['ir.rule'].domain_get(comodel._name)
             cond = " AND ".join(clauses) if clauses else "1=1"
+            if keep_ids:
+                cond += " AND {rel}.{id2} not in %s".format(**parts)
+                params.append(tuple(keep_ids))
+
             query = """ DELETE FROM {rel} USING {tables}
                         WHERE {rel}.{id1} IN %s AND {rel}.{id2}={table}.id AND {cond}
                     """.format(table=comodel._table, tables=','.join(tables), cond=cond, **parts)
@@ -2438,7 +2446,12 @@ class Many2many(_RelationalMulti):
             elif act[0] == 5:
                 unlink_all()
             elif act[0] == 6:
-                unlink_all()
+                # commands generated by convert_to_write and convert_to_read
+                # takes care of adding all exising IDs to the (6, 0 [...])
+                # It's therefore safe to expect that we only unlink all
+                # ides except thoses in the given list of ids
+                keep_ids = set(act[2])
+                unlink_all(keep_ids)
                 link(act[2])
 
 
diff --git a/odoo/osv/expression.py b/odoo/osv/expression.py
index bef1cb1c523..c1228b0cfd2 100644
--- a/odoo/osv/expression.py
+++ b/odoo/osv/expression.py
@@ -330,16 +330,6 @@ def generate_table_alias(src_table_alias, joined_tables=[]):
         return '%s' % alias, '%s' % _quote(alias)
     for link in joined_tables:
         alias += '__' + link[1]
-    # Use an alternate alias scheme if length exceeds the PostgreSQL limit
-    # of 63 characters.
-    if len(alias) >= 64:
-        # We have to fit a crc32 hash and one underscore
-        # into a 63 character alias. The remaining space we can use to add
-        # a human readable prefix.
-        alias_hash = hex(crc32(alias))[2:]
-        ALIAS_PREFIX_LENGTH = 63 - len(alias_hash) - 1
-        alias = "%s_%s" % (
-            alias[:ALIAS_PREFIX_LENGTH], alias_hash)
     return '%s' % alias, '%s as %s' % (_quote(joined_tables[-1][0]), _quote(alias))
 
 
